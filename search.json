[{"title":"Python中对文件和目录的常用操作---os模块的基本使用","url":"/file&directory/","content":"\nPython中对文件和目录的操作经常用到os模块.下面对其常用功能和实现方法作简单陈述:\n\n- 获得当前脚本文件的目录路径:\n\n  `os.getcwd()`\n\n- 返回指定目录下所包含的所有文件和目录:\n\n  `os.listdir()` ***例:*** 返回python目录下的文件 --> `os.listdir(\"/python/\")`\n\n- 删除一个文件:\n\n  `os.remove(filepath)`\n\n- 删除多个目录(空):\n\n  `os.remove(r\"path\")`\n\n- 检验路径是否是一个文件:\n\n  `os.path.isfile(filepath)`\n\n- 检验路径是否是一个目录:\n\n  `os.path.isdir(filepath)`\n\n- 判断是否为绝对路径:\n\n  `os.path.isabs()`\n\n- 检验路径是否存在:\n\n  `os.path.exists()` ***例:*** 查看python目录下是否存在new目录 --> `os.path.exists(r\"/python/new\")`\n\n- 获取路径名:\n\n  `os.path.dirname(filename)`\n\n- 获取文件名:\n\n  `os.path.basename(filepath)`\n\n- 重命名文件或目录:\n\n  `os.rename(old, new)`\n\n- 创建多级目录:\n\n  `os.makedirs(r\"/python/new/test\")`\n\n- 创建单个目录:\n\n  `os.mkdir(\"test\")`\n\n- 获取文件属性:\n\n  `os.stat(file)`\n\n- 获取文件大小:\n\n  `os.path.getsize(filename)`\n\n- 修改文件权限:\n\n  `os.chmod(file)`\n\n- 删除目录:\n\n  `os.rmdir(\"dirpath\")` ***(注:只能删除空目录)***","tags":["python"]},{"title":"Learn Python","url":"/learnpython-cn/","content":"\n\n```python\n\n# 用井字符开头的是单行注释\n\n\"\"\"\n多行字符串用三个引号\n包裹，也常被用来做多\n行注释\n\"\"\"\n\n####################################################\n## 1. 原始数据类型和运算符\n####################################################\n\n# 整数\n3  # => 3\n\n# 算术没有什么出乎意料的\n1 + 1  # => 2\n8 - 1  # => 7\n10 * 2  # => 20\n\n# 但是除法例外，会自动转换成浮点数\n35 / 5  # => 7.0\n5 / 3  # => 1.6666666666666667\n\n# 整数除法的结果都是向下取整\n5 // 3     # => 1\n5.0 // 3.0 # => 1.0 # 浮点数也可以\n-5 // 3  # => -2\n-5.0 // 3.0 # => -2.0\n\n# 浮点数的运算结果也是浮点数\n3 * 2.0 # => 6.0\n\n# 模除\n7 % 3 # => 1\n\n# x的y次方\n2**4 # => 16\n\n# 用括号决定优先级\n(1 + 3) * 2  # => 8\n\n# 布尔值\nTrue\nFalse\n\n# 用not取非\nnot True  # => False\nnot False  # => True\n\n# 逻辑运算符，注意and和or都是小写\nTrue and False #=> False\nFalse or True #=> True\n\n# 整数也可以当作布尔值\n0 and 2 #=> 0\n-5 or 0 #=> -5\n0 == False #=> True\n2 == True #=> False\n1 == True #=> True\n\n# 用==判断相等\n1 == 1  # => True\n2 == 1  # => False\n\n# 用!=判断不等\n1 != 1  # => False\n2 != 1  # => True\n\n# 比较大小\n1 < 10  # => True\n1 > 10  # => False\n2 <= 2  # => True\n2 >= 2  # => True\n\n# 大小比较可以连起来！\n1 < 2 < 3  # => True\n2 < 3 < 2  # => False\n\n# 字符串用单引双引都可以\n\"这是个字符串\"\n'这也是个字符串'\n\n# 用加号连接字符串\n\"Hello \" + \"world!\"  # => \"Hello world!\"\n\n# 字符串可以被当作字符列表\n\"This is a string\"[0]  # => 'T'\n\n# 用.format来格式化字符串\n\"{} can be {}\".format(\"strings\", \"interpolated\")\n\n# 可以重复参数以节省时间\n\"{0} be nimble, {0} be quick, {0} jump over the {1}\".format(\"Jack\", \"candle stick\")\n#=> \"Jack be nimble, Jack be quick, Jack jump over the candle stick\"\n\n# 如果不想数参数，可以用关键字\n\"{name} wants to eat {food}\".format(name=\"Bob\", food=\"lasagna\") #=> \"Bob wants to eat lasagna\"\n\n# 如果你的Python3程序也要在Python2.5以下环境运行，也可以用老式的格式化语法\n\"%s can be %s the %s way\" % (\"strings\", \"interpolated\", \"old\")\n\n# None是一个对象\nNone  # => None\n\n# 当与None进行比较时不要用 ==，要用is。is是用来比较两个变量是否指向同一个对象。\n\"etc\" is None  # => False\nNone is None  # => True\n\n# None，0，空字符串，空列表，空字典都算是False\n# 所有其他值都是True\nbool(0)  # => False\nbool(\"\")  # => False\nbool([]) #=> False\nbool({}) #=> False\n\n\n####################################################\n## 2. 变量和集合\n####################################################\n\n# print是内置的打印函数\nprint(\"I'm Python. Nice to meet you!\")\n\n# 在给变量赋值前不用提前声明\n# 传统的变量命名是小写，用下划线分隔单词\nsome_var = 5\nsome_var  # => 5\n\n# 访问未赋值的变量会抛出异常\n# 参考流程控制一段来学习异常处理\nsome_unknown_var  # 抛出NameError\n\n# 用列表(list)储存序列\nli = []\n# 创建列表时也可以同时赋给元素\nother_li = [4, 5, 6]\n\n# 用append在列表最后追加元素\nli.append(1)    # li现在是[1]\nli.append(2)    # li现在是[1, 2]\nli.append(4)    # li现在是[1, 2, 4]\nli.append(3)    # li现在是[1, 2, 4, 3]\n# 用pop从列表尾部删除\nli.pop()        # => 3 且li现在是[1, 2, 4]\n# 把3再放回去\nli.append(3)    # li变回[1, 2, 4, 3]\n\n# 列表存取跟数组一样\nli[0]  # => 1\n# 取出最后一个元素\nli[-1]  # => 3\n\n# 越界存取会造成IndexError\nli[4]  # 抛出IndexError\n\n# 列表有切割语法\nli[1:3]  # => [2, 4]\n# 取尾\nli[2:]  # => [4, 3]\n# 取头\nli[:3]  # => [1, 2, 4]\n# 隔一个取一个\nli[::2]   # =>[1, 4]\n# 倒排列表\nli[::-1]   # => [3, 4, 2, 1]\n# 可以用三个参数的任何组合来构建切割\n# li[始:终:步伐]\n\n# 用del删除任何一个元素\ndel li[2]   # li is now [1, 2, 3]\n\n# 列表可以相加\n# 注意：li和other_li的值都不变\nli + other_li   # => [1, 2, 3, 4, 5, 6]\n\n# 用extend拼接列表\nli.extend(other_li)   # li现在是[1, 2, 3, 4, 5, 6]\n\n# 用in测试列表是否包含值\n1 in li   # => True\n\n# 用len取列表长度\nlen(li)   # => 6\n\n\n# 元组是不可改变的序列\ntup = (1, 2, 3)\ntup[0]   # => 1\ntup[0] = 3  # 抛出TypeError\n\n# 列表允许的操作元组大都可以\nlen(tup)   # => 3\ntup + (4, 5, 6)   # => (1, 2, 3, 4, 5, 6)\ntup[:2]   # => (1, 2)\n2 in tup   # => True\n\n# 可以把元组合列表解包，赋值给变量\na, b, c = (1, 2, 3)     # 现在a是1，b是2，c是3\n# 元组周围的括号是可以省略的\nd, e, f = 4, 5, 6\n# 交换两个变量的值就这么简单\ne, d = d, e     # 现在d是5，e是4\n\n\n# 用字典表达映射关系\nempty_dict = {}\n# 初始化的字典\nfilled_dict = {\"one\": 1, \"two\": 2, \"three\": 3}\n\n# 用[]取值\nfilled_dict[\"one\"]   # => 1\n\n\n# 用keys获得所有的键。因为keys返回一个可迭代对象，所以在这里把结果包在list里。我们下面会详细介绍可迭代。\n# 注意：字典键的顺序是不定的，你得到的结果可能和以下不同。\nlist(filled_dict.keys())   # => [\"three\", \"two\", \"one\"]\n\n\n# 用values获得所有的值。跟keys一样，要用list包起来，顺序也可能不同。\nlist(filled_dict.values())   # => [3, 2, 1]\n\n\n# 用in测试一个字典是否包含一个键\n\"one\" in filled_dict   # => True\n1 in filled_dict   # => False\n\n# 访问不存在的键会导致KeyError\nfilled_dict[\"four\"]   # KeyError\n\n# 用get来避免KeyError\nfilled_dict.get(\"one\")   # => 1\nfilled_dict.get(\"four\")   # => None\n# 当键不存在的时候get方法可以返回默认值\nfilled_dict.get(\"one\", 4)   # => 1\nfilled_dict.get(\"four\", 4)   # => 4\n\n# setdefault方法只有当键不存在的时候插入新值\nfilled_dict.setdefault(\"five\", 5)  # filled_dict[\"five\"]设为5\nfilled_dict.setdefault(\"five\", 6)  # filled_dict[\"five\"]还是5\n\n# 字典赋值\nfilled_dict.update({\"four\":4}) #=> {\"one\": 1, \"two\": 2, \"three\": 3, \"four\": 4}\nfilled_dict[\"four\"] = 4  # 另一种赋值方法\n\n# 用del删除\ndel filled_dict[\"one\"]  # 从filled_dict中把one删除\n\n\n# 用set表达集合\nempty_set = set()\n# 初始化一个集合，语法跟字典相似。\nsome_set = {1, 1, 2, 2, 3, 4}   # some_set现在是{1, 2, 3, 4}\n\n# 可以把集合赋值于变量\nfilled_set = some_set\n\n# 为集合添加元素\nfilled_set.add(5)   # filled_set现在是{1, 2, 3, 4, 5}\n\n# & 取交集\nother_set = {3, 4, 5, 6}\nfilled_set & other_set   # => {3, 4, 5}\n\n# | 取并集\nfilled_set | other_set   # => {1, 2, 3, 4, 5, 6}\n\n# - 取补集\n{1, 2, 3, 4} - {2, 3, 5}   # => {1, 4}\n\n# in 测试集合是否包含元素\n2 in filled_set   # => True\n10 in filled_set   # => False\n\n\n####################################################\n## 3. 流程控制和迭代器\n####################################################\n\n# 先随便定义一个变量\nsome_var = 5\n\n# 这是个if语句。注意缩进在Python里是有意义的\n# 印出\"some_var比10小\"\nif some_var > 10:\n    print(\"some_var比10大\")\nelif some_var < 10:    # elif句是可选的\n    print(\"some_var比10小\")\nelse:                  # else也是可选的\n    print(\"some_var就是10\")\n\n\n\"\"\"\n用for循环语句遍历列表\n打印:\n    dog is a mammal\n    cat is a mammal\n    mouse is a mammal\n\"\"\"\nfor animal in [\"dog\", \"cat\", \"mouse\"]:\n    print(\"{} is a mammal\".format(animal))\n\n\"\"\"\n\"range(number)\"返回数字列表从0到给的数字\n打印:\n    0\n    1\n    2\n    3\n\"\"\"\nfor i in range(4):\n    print(i)\n\n\"\"\"\nwhile循环直到条件不满足\n打印:\n    0\n    1\n    2\n    3\n\"\"\"\nx = 0\nwhile x < 4:\n    print(x)\n    x += 1  # x = x + 1 的简写\n\n# 用try/except块处理异常状况\ntry:\n    # 用raise抛出异常\n    raise IndexError(\"This is an index error\")\nexcept IndexError as e:\n    pass    # pass是无操作，但是应该在这里处理错误\nexcept (TypeError, NameError):\n    pass    # 可以同时处理不同类的错误\nelse:   # else语句是可选的，必须在所有的except之后\n    print(\"All good!\")   # 只有当try运行完没有错误的时候这句才会运行\n\n\n# Python提供一个叫做可迭代(iterable)的基本抽象。一个可迭代对象是可以被当作序列\n# 的对象。比如说上面range返回的对象就是可迭代的。\n\nfilled_dict = {\"one\": 1, \"two\": 2, \"three\": 3}\nour_iterable = filled_dict.keys()\nprint(our_iterable) # => range(1,10) 是一个实现可迭代接口的对象\n\n# 可迭代对象可以遍历\nfor i in our_iterable:\n    print(i)    # 打印 one, two, three\n\n# 但是不可以随机访问\nour_iterable[1]  # 抛出TypeError\n\n# 可迭代对象知道怎么生成迭代器\nour_iterator = iter(our_iterable)\n\n# 迭代器是一个可以记住遍历的位置的对象\n# 用__next__可以取得下一个元素\nour_iterator.__next__()  #=> \"one\"\n\n# 再一次调取__next__时会记得位置\nour_iterator.__next__()  #=> \"two\"\nour_iterator.__next__()  #=> \"three\"\n\n# 当迭代器所有元素都取出后，会抛出StopIteration\nour_iterator.__next__() # 抛出StopIteration\n\n# 可以用list一次取出迭代器所有的元素\nlist(filled_dict.keys())  #=> Returns [\"one\", \"two\", \"three\"]\n\n\n\n####################################################\n## 4. 函数\n####################################################\n\n# 用def定义新函数\ndef add(x, y):\n    print(\"x is {} and y is {}\".format(x, y))\n    return x + y    # 用return语句返回\n\n# 调用函数\nadd(5, 6)   # => 印出\"x is 5 and y is 6\"并且返回11\n\n# 也可以用关键字参数来调用函数\nadd(y=6, x=5)   # 关键字参数可以用任何顺序\n\n\n# 我们可以定义一个可变参数函数\ndef varargs(*args):\n    return args\n\nvarargs(1, 2, 3)   # => (1, 2, 3)\n\n\n# 我们也可以定义一个关键字可变参数函数\ndef keyword_args(**kwargs):\n    return kwargs\n\n# 我们来看看结果是什么：\nkeyword_args(big=\"foot\", loch=\"ness\")   # => {\"big\": \"foot\", \"loch\": \"ness\"}\n\n\n# 这两种可变参数可以混着用\ndef all_the_args(*args, **kwargs):\n    print(args)\n    print(kwargs)\n\"\"\"\nall_the_args(1, 2, a=3, b=4) prints:\n    (1, 2)\n    {\"a\": 3, \"b\": 4}\n\"\"\"\n\n# 调用可变参数函数时可以做跟上面相反的，用*展开序列，用**展开字典。\nargs = (1, 2, 3, 4)\nkwargs = {\"a\": 3, \"b\": 4}\nall_the_args(*args)   # 相当于 foo(1, 2, 3, 4)\nall_the_args(**kwargs)   # 相当于 foo(a=3, b=4)\nall_the_args(*args, **kwargs)   # 相当于 foo(1, 2, 3, 4, a=3, b=4)\n\n\n# 函数作用域\nx = 5\n\ndef setX(num):\n    # 局部作用域的x和全局域的x是不同的\n    x = num # => 43\n    print (x) # => 43\n\ndef setGlobalX(num):\n    global x\n    print (x) # => 5\n    x = num # 现在全局域的x被赋值\n    print (x) # => 6\n\nsetX(43)\nsetGlobalX(6)\n\n\n# 函数在Python是一等公民\ndef create_adder(x):\n    def adder(y):\n        return x + y\n    return adder\n\nadd_10 = create_adder(10)\nadd_10(3)   # => 13\n\n# 也有匿名函数\n(lambda x: x > 2)(3)   # => True\n\n# 内置的高阶函数\nmap(add_10, [1, 2, 3])   # => [11, 12, 13]\nfilter(lambda x: x > 5, [3, 4, 5, 6, 7])   # => [6, 7]\n\n# 用列表推导式可以简化映射和过滤。列表推导式的返回值是另一个列表。\n[add_10(i) for i in [1, 2, 3]]  # => [11, 12, 13]\n[x for x in [3, 4, 5, 6, 7] if x > 5]   # => [6, 7]\n\n####################################################\n## 5. 类\n####################################################\n\n\n# 定义一个继承object的类\nclass Human(object):\n\n    # 类属性，被所有此类的实例共用。\n    species = \"H. sapiens\"\n\n    # 构造方法，当实例被初始化时被调用。注意名字前后的双下划线，这是表明这个属\n    # 性或方法对Python有特殊意义，但是允许用户自行定义。你自己取名时不应该用这\n    # 种格式。\n    def __init__(self, name):\n        # 将参数分配给实例的name属性\n        self.name = name\n\n    # 实例方法，第一个参数总是self，就是这个实例对象\n    def say(self, msg):\n        return \"{name}: {message}\".format(name=self.name, message=msg)\n\n    # 类方法，被所有此类的实例共用。第一个参数是这个类对象。\n    @classmethod\n    def get_species(cls):\n        return cls.species\n\n    # 静态方法。调用时没有实例或类的绑定。\n    @staticmethod\n    def grunt():\n        return \"*grunt*\"\n\n\n# 构造一个实例\ni = Human(name=\"Ian\")\nprint(i.say(\"hi\"))     # 印出 \"Ian: hi\"\n\nj = Human(\"Joel\")\nprint(j.say(\"hello\"))  # 印出 \"Joel: hello\"\n\n# 调用一个类方法\ni.get_species()   # => \"H. sapiens\"\n\n# 改一个共用的类属性\nHuman.species = \"H. neanderthalensis\"\ni.get_species()   # => \"H. neanderthalensis\"\nj.get_species()   # => \"H. neanderthalensis\"\n\n# 调用静态方法\nHuman.grunt()   # => \"*grunt*\"\n\n\n####################################################\n## 6. 模块\n####################################################\n\n# 用import导入模块\nimport math\nprint(math.sqrt(16))  # => 4.0\n\n# 也可以从模块中导入个别值\nfrom math import ceil, floor\nprint(ceil(3.7))  # => 4.0\nprint(floor(3.7))   # => 3.0\n\n# 可以导入一个模块中所有值\n# 警告：不建议这么做\nfrom math import *\n\n# 如此缩写模块名字\nimport math as m\nmath.sqrt(16) == m.sqrt(16)   # => True\n\n# Python模块其实就是普通的Python文件。你可以自己写，然后导入，\n# 模块的名字就是文件的名字。\n\n# 你可以这样列出一个模块里所有的值\nimport math\ndir(math)\n\n\n####################################################\n## 7. 高级用法\n####################################################\n\n# 用生成器(generators)方便地写惰性运算\ndef double_numbers(iterable):\n    for i in iterable:\n        yield i + i\n\n# 生成器只有在需要时才计算下一个值。它们每一次循环只生成一个值，而不是把所有的\n# 值全部算好。这意味着double_numbers不会生成大于15的数字。\n#\n# range的返回值也是一个生成器，不然一个1到900000000的列表会花很多时间和内存。\n#\n# 如果你想用一个Python的关键字当作变量名，可以加一个下划线来区分。\nrange_ = range(1, 900000000)\n# 当找到一个 >=30 的结果就会停\nfor i in double_numbers(range_):\n    print(i)\n    if i >= 30:\n        break\n\n\n# 装饰器(decorators)\n# 这个例子中，beg装饰say\n# beg会先调用say。如果返回的say_please为真，beg会改变返回的字符串。\nfrom functools import wraps\n\n\ndef beg(target_function):\n    @wraps(target_function)\n    def wrapper(*args, **kwargs):\n        msg, say_please = target_function(*args, **kwargs)\n        if say_please:\n            return \"{} {}\".format(msg, \"Please! I am poor :(\")\n        return msg\n\n    return wrapper\n\n\n@beg\ndef say(say_please=False):\n    msg = \"Can you buy me a beer?\"\n    return msg, say_please\n\n\nprint(say())  # Can you buy me a beer?\nprint(say(say_please=True))  # Can you buy me a beer? Please! I am poor :(\n\n```\n\n","tags":["python"]},{"title":"Hello World","url":"/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n"}]